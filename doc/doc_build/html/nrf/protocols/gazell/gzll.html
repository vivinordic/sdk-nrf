<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gazell Link Layer &mdash; nRF Connect SDK 2.3.99 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/nordic.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/nrf.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" /> 
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=G-ZPVZRKFQJR"></script>
        <script src="../../_static/js/ga-tracker.js"></script>
        <script data-culture="EN" id="CookieConsent" type="text/javascript" src="https://policy.app.cookieinformation.com/uc.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/js/theme.js"></script>
<script
  type="text/javascript"
  src="../../_static/js/ncs.js"
></script>
<script src="../../_static/js/bootstrap.bundle.min.js"></script>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Gazell Pairing" href="gzp.html" />
    <link rel="prev" title="Gazell" href="index.html" />
<link
  href="../../_static/css/bootstrap.min.css"
  rel="stylesheet"
/>
<link
  rel="shortcut icon"
  href="../../_static/images/favicon.ico"
/>

</head>

<body class="wy-body-for-nav">
<div class="announcement"></div>
<div class="d-print-none ncs-header">
  <div class="container-xl ncs-header-top">
    <div class="row h-100">
      <div class="d-none d-md-block col-2">
        <div class="bg-white py-4 px-3 ml-2 ncs-header-logo">
          <img
            class="ncs-header-logo"
            src="../../_static/images/nordic-logo.png"
            alt=""
          />
        </div>
      </div>
      <div
        class="col-8 col-md-7 pl-md-4 d-flex align-self-center justify-content-center"
      >
        <form class="w-75" action="../../search.html" method="get">
          <div class="form-group">
            <input
              type="text"
              name="q"
              class="ncs-search-input form-control"
              placeholder="Search all docs..."
            />
          </div>
        </form>
      </div>
      <div class="col-4 col-md-3 d-md-block p-3 text-end">
        <div class="dropdown">
          <button
            class="btn dropdown-toggle ncs-btn-versions"
            type="button"
            id="dropdownMenuButton1"
            data-bs-toggle="dropdown"
            aria-expanded="false"
          >
            <span class="d-none d-md-inline">nRF Connect SDK</span>
            <span id="ncsversion" class="d-inline"></span>
          </button>
          <div class="dropdown-menu" aria-labelledby="dropdownMenuButton"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="ncs-header-nav">
    <div class="container-xl">
      <div class="row">
        <div class="col col-12 d-flex justify-content-center">
          <nav class="navbar navbar-dark navbar-expand-lg p-0">
            <span class="navbar-brand d-block d-lg-none py-2 pl-1"
              >Documentation sets</span
            >
            <button
              class="navbar-toggler"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#navbarNavAltMarkup"
              aria-controls="navbarNavAltMarkup"
              aria-expanded="false"
              aria-label="Toggle navigation"
            >
              <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
              <ul class="navbar-nav">
                <li class="nav-item active py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../nrf/index.html"
                    >nRF Connect SDK</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../nrfx/index.html"
                    >nrfx</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../nrfxlib/README.html"
                    >nrfxlib</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../zephyr/index.html"
                    >Zephyr Project</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../mcuboot/wrapper.html"
                    >MCUboot</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../tfm/index.html"
                    >Trusted Firmware-M</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../matter/index.html"
                    >Matter</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
                <li class="nav-item  py-1 px-3">
                  <a
                    class="nav-link"
                    href="../../../kconfig/index.html"
                    >Kconfig Reference</a
                  >
                </li>
                <li><hr class="dropdown-divider" /></li>
              </ul>
            </div>
          </nav>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> nRF Connect SDK
          </a>
              <div class="version">
                2.3.99
              </div>
<div id="searchbox" role="search">
  <div class="searchformwrapper">
    <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
  </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_model.html">Development model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../app_dev.html">Application development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security.html">Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ecosystem_integration.html">Ecosystems integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nrf91.html">Working with nRF91 Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nrf70.html">Working with nRF70 Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nrf53.html">Working with nRF53 Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nrf52.html">Working with nRF52 Series</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../protocols.html">Protocols</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../ble/index.html">Bluetooth LE Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bt_mesh/index.html">Bluetooth mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../esb/index.html">Enhanced ShockBurst (ESB)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Gazell</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Gazell Link Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#features">Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resources-required">Resources required</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gazell-network">Gazell network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-up-a-gazell-application">Setting up a Gazell application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disabling-gazell">Disabling Gazell</a></li>
<li class="toctree-l4"><a class="reference internal" href="#packet-transactions">Packet transactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#packet-identification">Packet identification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fifos">FIFOs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#callback-queueing">Callback queueing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timeslots">Timeslots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frequency-hopping">Frequency hopping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization">Synchronization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transmission-statistics">Transmission statistics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gzp.html">Gazell Pairing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../matter/index.html">Matter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../multiprotocol/index.html">Multiprotocol support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nfc/index.html">Near Field Communication (NFC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../thread/index.html">Thread</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wifi/index.html">Wi-Fi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zigbee/index.html">Zigbee</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples.html">Samples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers.html">Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../known_issues.html">Known issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software_maturity.html">Software maturity levels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">About this documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">nRF Connect SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../protocols.html">Protocols</a></li>
          <li class="breadcrumb-item"><a href="index.html">Gazell</a></li>
      <li class="breadcrumb-item active">Gazell Link Layer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/protocols/gazell/gzll.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="gazell-link-layer">
<span id="ug-gzll"></span><h1>Gazell Link Layer<a class="headerlink" href="#gazell-link-layer" title="Permalink to this heading"></a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#features" id="id13">Features</a></p></li>
<li><p><a class="reference internal" href="#configuration" id="id14">Configuration</a></p></li>
<li><p><a class="reference internal" href="#resources-required" id="id15">Resources required</a></p></li>
<li><p><a class="reference internal" href="#gazell-network" id="id16">Gazell network</a></p></li>
<li><p><a class="reference internal" href="#setting-up-a-gazell-application" id="id17">Setting up a Gazell application</a></p>
<ul>
<li><p><a class="reference internal" href="#setting-up-a-device" id="id18">Setting up a Device</a></p></li>
<li><p><a class="reference internal" href="#setting-up-a-host" id="id19">Setting up a Host</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#disabling-gazell" id="id20">Disabling Gazell</a></p></li>
<li><p><a class="reference internal" href="#packet-transactions" id="id21">Packet transactions</a></p></li>
<li><p><a class="reference internal" href="#packet-identification" id="id22">Packet identification</a></p>
<ul>
<li><p><a class="reference internal" href="#pipes-and-addressing" id="id23">Pipes and addressing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fifos" id="id24">FIFOs</a></p>
<ul>
<li><p><a class="reference internal" href="#device-fifo-handling" id="id25">Device FIFO handling</a></p></li>
<li><p><a class="reference internal" href="#host-fifo-handling" id="id26">Host FIFO handling</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#callback-queueing" id="id27">Callback queueing</a></p></li>
<li><p><a class="reference internal" href="#timeslots" id="id28">Timeslots</a></p></li>
<li><p><a class="reference internal" href="#frequency-hopping" id="id29">Frequency hopping</a></p></li>
<li><p><a class="reference internal" href="#synchronization" id="id30">Synchronization</a></p></li>
<li><p><a class="reference internal" href="#backwards-compatibility" id="id31">Backwards compatibility</a></p>
<ul>
<li><p><a class="reference internal" href="#channel-tables" id="id32">Channel tables</a></p></li>
<li><p><a class="reference internal" href="#timeslot-periods" id="id33">Timeslot periods</a></p></li>
<li><p><a class="reference internal" href="#emulating-legacy-gazell-roles" id="id34">Emulating legacy Gazell roles</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#transmission-statistics" id="id35">Transmission statistics</a></p></li>
</ul>
</div>
<p>Gazell Link Layer minimizes the power consumption of the power-sensitive peripheral devices.
Gazell uses the central hub (Host side) with its more relaxed power constraints to keep the link open while the peripheral devices can sleep and save on power consumption.
A typical example of this is a wireless mouse communicating with a USB dongle that is inserted into a computer.</p>
<p>Gazell provides a switching and synchronization scheme that reduces interference and provides wireless coexistence features, enabling high throughput and low latency.</p>
<section id="features">
<h2><a class="toc-backref" href="#id13">Features</a><a class="headerlink" href="#features" title="Permalink to this heading"></a></h2>
<p>Gazell Link Layer provides the following features:</p>
<ul class="simple">
<li><p>Support for star network topology with one Host and up to eight Devices.</p></li>
<li><p>Bidirectional data transfer between each Host and Device.</p></li>
<li><p>Channel hopping functionality that gives a reliable wireless link in environments with interference from other radio sources.</p></li>
<li><p>Packet acknowledgment and automatic packet retransmission functionality to prevent data loss.</p></li>
<li><p>Individual TX and RX FIFOs for every data pipe.</p></li>
<li><p>Backward compatible with legacy nRF24L IC Gazell.</p></li>
<li><p>Devices self-synchronize to the Host, meaning:</p>
<ul>
<li><p>No connection packets are required to setup a link.</p></li>
<li><p>No polling packets are required to maintain a link.</p></li>
<li><p>Devices can enter and remove themselves from the network at any time.</p></li>
</ul>
</li>
<li><p>Generates transmission statistics for each RF channel.</p></li>
</ul>
</section>
<section id="configuration">
<span id="ug-gzll-configuration"></span><h2><a class="toc-backref" href="#id14">Configuration</a><a class="headerlink" href="#configuration" title="Permalink to this heading"></a></h2>
<p>To enable the Gazell support in the nRF Connect SDK, set the following Kconfig options:</p>
<ul class="simple">
<li><p><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_GZLL</span></code> - This option enables the <span class="xref std std-ref">nrfxlib:gzll</span> library.</p></li>
<li><p><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_CLOCK_CONTROL_NRF</span></code> - This option enables HFCLK controller support for the nRF52 Series devices.</p></li>
<li><p><code class="xref kconfig kconfig-option docutils literal notranslate"><span class="pre">CONFIG_GAZELL</span></code> - This option enables the <a class="reference internal" href="../../libraries/gazell/gzll_glue.html#gzll-glue"><span class="std std-ref">Gazell Link Layer glue</span></a> module.</p></li>
</ul>
</section>
<section id="resources-required">
<span id="ug-gzll-resources"></span><h2><a class="toc-backref" href="#id15">Resources required</a><a class="headerlink" href="#resources-required" title="Permalink to this heading"></a></h2>
<p>Gazell uses a fixed set of peripheral resources in System on Chips of the nRF52 series.
To ensure correct operation, Gazell requires exclusive access to the following resources:</p>
<ul class="simple">
<li><p>Radio</p></li>
<li><p>Timer</p></li>
<li><p>Three PPI channels</p></li>
<li><p>Software interrupt (SWI)</p></li>
</ul>
<p>The <a class="reference internal" href="../../libraries/gazell/gzll_glue.html#gzll-glue"><span class="std std-ref">Gazell Link Layer glue</span></a> module specifies the resources used by the <span class="xref std std-ref">nrfxlib:gzll</span> library.</p>
<p>The Gazell interrupt priorities are configured by applications.
The radio and timer interrupt handlers should run at priority level 0 (highest priority), and the Gazell callback functions can run at priority level 1.
To avoid blocking Gazell operations, applications can run at priority level 2 or higher.</p>
<p>You can customize Gazell at runtime for a range of different applications.
See the <span class="xref std std-ref">nrfxlib:gzll</span> and <span class="xref std std-ref">nrfxlib:gzll_api</span> for a list of configuration functions as well as the default and constant parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Editing the header file containing the default and constant parameters does not change their value when compiling a new project.
These values are provided as a useful reference when making an application with the precompiled library.</p>
</div>
</section>
<section id="gazell-network">
<h2><a class="toc-backref" href="#id16">Gazell network</a><a class="headerlink" href="#gazell-network" title="Permalink to this heading"></a></h2>
<p>Gazell has the following two roles available in its network:</p>
<ul class="simple">
<li><p>Device: an initiator role, where the Device transmits packets periodically.</p></li>
<li><p>Host: a listening role, where the Host works mainly as a receiver and only transmits ACK packets back to the Device.
The ACK packets can optionally carry payload (enabling duplex communication).</p></li>
</ul>
<p>One application can only work in a single Gazell role at a time.
However, the role can be switched during runtime.</p>
<p>A member of a Gazell star network is either a Host or Device, and up to eight Devices can communicate with a single Host.
Each Host can communicate with up to eight Devices, and each Device communicates to a single Host.</p>
<figure class="align-default" id="id6">
<img alt="Gazell star network" src="../../_images/gzll_fig1_star_network.svg" /><figcaption>
<p><span class="caption-text">Gazell star network</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Once enabled, the Host in a Gazell network is always listening, and the Device always initiates the communication.
Each packet that a Device sends is required to be acknowledged by the Host.
The Host can send data to the Device by piggybacking data in an acknowledgment (ACK) packet.
Therefore, the Host must wait for a packet from the Device before it can send any data to it.</p>
<p>You can build more sophisticated Gazell networks, since a single Device can speak to at least two Hosts and any node can change between the two roles.
However, this requires the application to coordinate such a network.</p>
<p>This document focuses on the typical use case of a star network with static roles.</p>
</section>
<section id="setting-up-a-gazell-application">
<h2><a class="toc-backref" href="#id17">Setting up a Gazell application</a><a class="headerlink" href="#setting-up-a-gazell-application" title="Permalink to this heading"></a></h2>
<p>Gazell automatically takes care of all synchronization and packet handling.
You need to add payloads to the transmit (TX) FIFOs and read payloads from the receive (RX) FIFOs.
Gazell automatically notifies the application when a packet is received.</p>
<p>To set up a Gazell application, complete the following steps:</p>
<ol class="arabic">
<li><p>Initialize Gazell Link Layer glue code using <a class="reference internal" href="../../libraries/gazell/gzll_glue.html#c.gzll_glue_init" title="gzll_glue_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">gzll_glue_init()</span></code></a>.</p></li>
<li><p>Initialize Gazell using <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_init()</span></code> and choose either Host or Device.</p></li>
<li><p>Reconfigure Gazell’s default parameters.</p>
<p>At a minimum, reconfigure the addresses and channels to avoid interfering with other Gazell networks.</p>
</li>
<li><p>Enable Gazell using <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_enable()</span></code>.</p></li>
<li><p>Continue to either <a class="reference internal" href="#setting-up-a-device">Setting up a Device</a> to set up a Device, or <a class="reference internal" href="#setting-up-a-host">Setting up a Host</a> to setup a Host.</p></li>
</ol>
<section id="setting-up-a-device">
<h3><a class="toc-backref" href="#id18">Setting up a Device</a><a class="headerlink" href="#setting-up-a-device" title="Permalink to this heading"></a></h3>
<p>If the node is a Device, complete the following steps:</p>
<ol class="arabic">
<li><p>Add payloads to the TX FIFO using <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_add_packet_to_tx_fifo()</span></code>.</p></li>
<li><p>Handle the returned ACK packet when the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_device_tx_success()</span></code> callback is called.</p>
<p>Fetch the payloads from the RX FIFO using <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_fetch_packet_from_rx_fifo()</span></code>.</p>
</li>
<li><p>Handle the failed packet transmissions when the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_device_tx_failed()</span></code> callback is called.</p>
<p>Failed packets are automatically removed from the TX FIFO.</p>
</li>
</ol>
</section>
<section id="setting-up-a-host">
<h3><a class="toc-backref" href="#id19">Setting up a Host</a><a class="headerlink" href="#setting-up-a-host" title="Permalink to this heading"></a></h3>
<p>If the node is a Host, start listening by completing the following steps:</p>
<ol class="arabic">
<li><p>Handle the received data packets when the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_host_rx_data_ready()</span></code> callback is called.</p>
<p>Fetch the packets from the RX FIFO using <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_fetch_from_rx_fifo()</span></code>.</p>
</li>
<li><p>Add any payloads to send to the TX FIFO using <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_add_packet_to_tx_fifo()</span></code>.</p></li>
</ol>
</section>
</section>
<section id="disabling-gazell">
<h2><a class="toc-backref" href="#id20">Disabling Gazell</a><a class="headerlink" href="#disabling-gazell" title="Permalink to this heading"></a></h2>
<p>You can also disable Gazell at any time using the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_disable()</span></code> function.</p>
<p>When this is called, Gazell completes any ongoing transmission or reception before being disabled.
(That is, until the end of the current timeslot, see <a class="reference internal" href="#gazell-timeslots"><span class="std std-ref">Timeslots</span></a>).
When the disabling operation is complete, Gazell calls the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_disabled()</span></code> function.
When this callback is completed, the Gazell CPU context, radio and Gazell timer stop.</p>
<p>You can now call any of the configuration set functions, which will be valid, once Gazell is enabled again.</p>
</section>
<section id="packet-transactions">
<h2><a class="toc-backref" href="#id21">Packet transactions</a><a class="headerlink" href="#packet-transactions" title="Permalink to this heading"></a></h2>
<p>A typical packet transaction between a Device and a Host consists of a Device initiating the transaction by sending a data packet to the Host and the Host sending an ACK packet in return.</p>
<p>When the Device receives an ACK packet, it knows that the initial packet was successfully transmitted and the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_device_tx_success()</span></code> callback function is called to notify the application of this.</p>
<p>Similarly, when the Host receives the initial packet, the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_host_rx_data_ready()</span></code> callback function is called to notify to the application that a new packet has been received.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These callback functions are actually queued so that the application avoids race conditions.
See <a class="reference internal" href="#gazell-cb-queue"><span class="std std-ref">Callback queueing</span></a>.</p>
</div>
<figure class="align-default" id="id7">
<img alt="Successful packet transaction" src="../../_images/gzll_fig7_host_dev_trans_ok.svg" /><figcaption>
<p><span class="caption-text">Successful packet transaction</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>A transaction can fail if the Host did not receive the initial packet from the Device, or the Device did not receive the corresponding ACK packet correctly.
Gazell ignores packets with a failing Cyclic Redundancy Check (CRC).</p>
<p>If a transaction fails, the Device makes an attempt to retransmit the initial packet to the Host until the ACK is finally received or the maximum number of transmission attempts is reached.
If the maximum number of transmission attempts is reached, the retransmissions stop and the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_device_tx_failed()</span></code> callback is called.</p>
<p>If only the ACK packet sent from the Host to the Device is lost, but the Host receives successfully both the initial packet and the subsequent retransmission attempts, the Host discards the repeated packets.
The ACK packets are still sent in return to the Device.
This prevents the application receiving duplicate data packets at the Host.</p>
<figure class="align-default" id="id8">
<img alt="Example on failing packet transaction." src="../../_images/gzll_fig8_host_dev_trans_fail.svg" /><figcaption>
<p><span class="caption-text">Example on failing packet transaction.</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>In the figure, the maximum number of allowed transmission attempts is set to 3.</p>
</section>
<section id="packet-identification">
<h2><a class="toc-backref" href="#id22">Packet identification</a><a class="headerlink" href="#packet-identification" title="Permalink to this heading"></a></h2>
<p>Any packet transmitted from a Device to a Host is uniquely identified by a two bit packet ID field in the packet header together with the packet’s 16-bit Cyclic Redundancy Check (CRC).
This packet ID is used to distinguish a new packet from the previous packet, if it has the same payload.</p>
<p>On the Host side, retransmitted packets are discarded and not added to an RX FIFO.</p>
<section id="pipes-and-addressing">
<h3><a class="toc-backref" href="#id23">Pipes and addressing</a><a class="headerlink" href="#pipes-and-addressing" title="Permalink to this heading"></a></h3>
<p>Each logical address on the nodes is termed a <em>pipe</em>.
Each pipe maps to one on-air address used when transmitting or receiving packets.</p>
<p>The on-air addresses are composed of a 2-4 bytes long “base address” in addition to a 1-byte prefix address.
The radio of the nRF52 Series uses an alternating sequence of 0s and 1s as the preamble of the packet.
Therefore, for packets to be received correctly, the most significant byte of the base address should not be an alternating sequence of 0s and 1s, that is, it should not be 0x55 or 0xAA.</p>
<p>Pipe 0 has its own unique base address, which is base address 0, while pipes 1-7 use the same base address, which is base address 1.</p>
<p>Each of the eight pipes have a unique byte-long prefix address.</p>
<p>On-air, the most significant bit of each address byte is transmitted first.
The most significant byte of the four bytes long base address is the first transmitted address byte, while the prefix byte is transmitted last.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The byte order in Gazell and the nRF52 Series radio peripheral are not the same.
This is because the address bytes are rearranged in Gazell to match radio of the nRF24L IC.</p>
</div>
</section>
</section>
<section id="fifos">
<h2><a class="toc-backref" href="#id24">FIFOs</a><a class="headerlink" href="#fifos" title="Permalink to this heading"></a></h2>
<p>All eight pipes on both the Device and the Host have two first in first out (FIFO) buffers that can hold packets.
Each pipe has a TX FIFO and an RX FIFO.
The total number of packets in the FIFOs is six, while every individual TX or RX FIFO (8 pipes x 2 = 16 in total) can store three packets.</p>
<section id="device-fifo-handling">
<h3><a class="toc-backref" href="#id25">Device FIFO handling</a><a class="headerlink" href="#device-fifo-handling" title="Permalink to this heading"></a></h3>
<p>When Gazell is enabled in Device role, any packets uploaded to a TX FIFO will be transmitted at the next opportunity.
If several TX FIFOs contain packets, the various TX FIFOs are serviced in a round robin fashion, meaning that no TX FIFOs will experience starvation even when packets are continuously added to other TX FIFOs.</p>
<p>When an ACK is successfully received from a Host, it implies that the payload was successfully received and added to the Host’s RX FIFO.
The successfully transmitted packet is removed from the TX FIFO so that the next packet in the FIFO can be transmitted.</p>
<p>If an ACK received by a Device contains a payload, it is added to the pipe’s RX FIFO.</p>
<p>If the RX FIFO for a specific pipe on a Device is full and cannot accommodate any new packets, no new packets are sent from the Device on this pipe.
A payload received in an ACK does not need to be discarded due to a full RX FIFO.</p>
</section>
<section id="host-fifo-handling">
<h3><a class="toc-backref" href="#id26">Host FIFO handling</a><a class="headerlink" href="#host-fifo-handling" title="Permalink to this heading"></a></h3>
<p>When Gazell is enabled in Host role, all enabled pipes (addresses) are simultaneously monitored for incoming packets.</p>
<p>If a new packet is received and the pipe’s RX FIFO has available space, it is added to the RX FIFO and an ACK is sent in return to the Device.
If the pipe’s TX FIFO contains any packets, the next serviceable packet is attached as a payload in the ACK packet.
To have a TX packet attached to an ACK, it needs to be uploaded to the TX FIFO before the packet is received.</p>
<p>Since the Device does not always receive the ACK successfully, the data payload added to the ACK is not removed from the TX FIFO immediately.
The TX packet is removed from the TX FIFO when a new packet (new packet ID or CRC) is received on the same pipe.
The new packet sent from the Device serves as an acknowledgment of the ACK sent previously by the Host.
ACKs sent in reply to retransmission attempts contain the same TX payload.</p>
<p>When the Host is handling packets on multiple pipes, ensure the ACK payloads in the TX FIFOs on pipes that are no longer used, are not taking up space in the memory pool and consequently blocking communication on other pipes.
To avoid such congestion, the application on the Host can flush the TX FIFOs on the unused pipes.</p>
</section>
</section>
<section id="callback-queueing">
<span id="gazell-cb-queue"></span><h2><a class="toc-backref" href="#id27">Callback queueing</a><a class="headerlink" href="#callback-queueing" title="Permalink to this heading"></a></h2>
<p>Gazell has an internal callback queue for queueing pending callbacks.
This queue steps in when Gazell attempts to call a new callback function while the application is already servicing the previous one.</p>
<p>For example, if a new packet is received by the Host while the application is already servicing the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_host_rx_data_ready()</span></code> callback from a previously received packet, the callback for the latest packet is added to the callback queue and serviced at a later opportunity.
In this case, <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_host_rx_data_ready()</span></code> is called once for every received packet, and the application does not need to handle the potential race condition scenario where a new packet is being received just before the application is about to exit the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_host_rx_data_ready()</span></code> function.</p>
<p>In a Device, the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_device_tx_success()</span></code> callback is called once for every packet receiving an ACK, even when a new packet is receiving an ACK while the application is servicing the callback of a previously transmitted packet.</p>
<p>The size of the callback queue is given by <code class="xref c c-macro docutils literal notranslate"><span class="pre">NRF_GZLL_CONST_CALLBACK_QUEUE_LENGTH</span></code> but it cannot be configured.</p>
</section>
<section id="timeslots">
<span id="gazell-timeslots"></span><h2><a class="toc-backref" href="#id28">Timeslots</a><a class="headerlink" href="#timeslots" title="Permalink to this heading"></a></h2>
<p>Timeslot is a core parameter in Gazell.
It can be seen as the internal Gazell “heartbeat”.</p>
<p>In a Device, any packet transmission (both new packets and retransmitted packets) starts at the beginning of a timeslot, and only one packet transmission (including ACK) can take place within a timeslot.</p>
<figure class="align-default" id="id9">
<img alt="Relation between Device operation and timeslot" src="../../_images/gzll_fig2_device_heartbeat.svg" /><figcaption>
<p><span class="caption-text">Relation between Device operation and timeslot</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>On the Host side, the radio initiates a radio startup at the beginning of the timeslot to start listening.
In addition, it may optionally change the RF channel it listens to.</p>
<figure class="align-default" id="id10">
<img alt="Relation between Host operation and timeslot" src="../../_images/gzll_fig3_host_heartbeat.svg" /><figcaption>
<p><span class="caption-text">Relation between Host operation and timeslot</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>To set the period for the heartbeat, use the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_timeslot_period()</span></code> function.</p>
</section>
<section id="frequency-hopping">
<h2><a class="toc-backref" href="#id29">Frequency hopping</a><a class="headerlink" href="#frequency-hopping" title="Permalink to this heading"></a></h2>
<p>To ensure good coexistence performance with other radio products operating in the same 2.4 GHz frequency band as Gazell, such as Wi-Fi or Bluetooth, Gazell implements mechanisms for hopping between various radio frequency channels.</p>
<p>When enabled, Gazell picks channels from a predefined channel table.</p>
<p>The application can reconfigure the contents and size of the channel table.
The Device and Host must be configured to have the exact same channel table.
The application can pick from a full set of 80 channels.
A table of 3-7 channels is proven to give a satisfactory coexistence performance in most environments.</p>
<p>Too large channel table may increase the transmission latency and power consumption, while using a too small channel table may decrease the coexistence performance.</p>
<p>Following are the core parameters deciding the channel hopping behavior:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code> (applies to Host and “in sync” Device, set by <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_timeslots_per_channel()</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timeslots_per_channel_when_device_out_of_sync</span></code> (applies to “out of sync” Device only, set by <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_timeslots_per_channel_when_device_out_of_sync()</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel_selection_policy</span></code> (applies to “in sync” Device only, set by <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_device_channel_selection_policy()</span></code>).</p></li>
</ul>
<p>Which one to use depends on whether Gazell is “in sync” or “out of sync”, see <a class="reference internal" href="#gazell-sync"><span class="std std-ref">Synchronization</span></a>.
Therefore, <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code> is used instead of these terms.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code> parameter sets the number of timeslots Gazell has on a single channel before the channel is changed.
In the next timeslot with a channel shift, Gazell picks the next channel from the predefined channel table, cycling back to the beginning of the channel table if required.</p>
<figure class="align-default" id="id11">
<img alt="Host and Device channel switching. Here, timeslots_per_channel = 2." src="../../_images/gzll_fig4_device_channel_switch.svg" /><figcaption>
<p><span class="caption-text">Host and Device channel switching. Here, <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code> = 2.</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Host channel switching is the same as Device channel switching.</p>
</div>
<p>In the Device role, <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code> can also be seen as the number of transmission attempts spent on each channel before switching the channel.
This is because there is at least one transmission attempt for every timeslot.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">channel_selection_policy</span></code> parameter is used by a Device in sync to decide the initial channel to be used when sending a new packet to a Host (that is, for the first time the new packet is sent, not for the retransmission attempts).</p>
<p>Once synchronized with the Host, the Device can send either on the current channel that it believes the Host is on or on the last successful channel.
To configure this, use the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_device_channel_selection_policy()</span></code> function.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">channel_selection_policy</span></code> parameter can take the following two values:</p>
<ul class="simple">
<li><p><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</span></code></p></li>
<li><p><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_CURRENT</span></code></p></li>
</ul>
<p>If you choose the <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</span></code> policy, the Device starts sending packets on the channel it last had a successfully acknowledged transmission.
This policy is the most robust against static interference.
Once the Device finds a quiet channel, it should be able to continue using this channel.</p>
<p>If you choose the <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_CURRENT</span></code> policy, the Device sends on the channel it believes the Host is currently listening to.
This achieves the lowest latency and highest throughput of the two policies as the Device does not have to wait for the Host to be listening to a specific channel.
This policy is frequency hopping.
The disadvantage of this policy is that if there is static interference on a particular channel, the Device wastes packets attempting to send on this channel.
The application can reconfigure the channel table during runtime to overcome this.</p>
<p>The channel selection policy only applies to the initially transmitted packet.
If the transmission of this initial packet fails, the following retransmission attempts are always sent in the channel the Device believes the Host is monitoring.</p>
<p>If Gazell is “out of sync”, it always starts the packet transmission immediately using the previous successful transmission channel.
If Gazell has not transmitted a successful packet and thus has no previous successful channel to relate to, it starts using the first channel in the channel table.</p>
</section>
<section id="synchronization">
<span id="gazell-sync"></span><h2><a class="toc-backref" href="#id30">Synchronization</a><a class="headerlink" href="#synchronization" title="Permalink to this heading"></a></h2>
<p>The internal timeslot, or “heartbeat”, mechanism of Gazell is used to obtain synchronous communication while still enabling efficient channel switching.
This mechanism is useful when a Device needs to switch to a new channel while there is radio interference on the current channel.</p>
<p>Each Gazell Device has two synchronization states: in sync and out of sync.</p>
<p>On the Host, the internal heartbeat timer is always running when Gazell is enabled, independent of the Devices’ synchronization state.</p>
<p>On the Device, the heartbeat timer only runs as long as the Device is “in sync” or as long as there are packets to be sent.
If the timer has been stopped and packets are added to a TX FIFO, the timer starts immediately.</p>
<p>Before any packets have been successfully received and acknowledged, the Device is out of sync.
In this state, the Device switches channel determined by the <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel_when_device_out_of_sync</span></code> parameter.
The Device switches channel at a slower rate than the Host (as determined by <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code>) so that the Device eventually transmits a packet on the same channel that the Host is on.</p>
<p>When a Device successfully transmits a packet, that is when an ACK packet is received from the Host, it enters the in sync state, as it now has the information needed for continuing to guess the following channels the Host is listening to.</p>
<p>For knowing when to change channel, Gazell has an internal <code class="docutils literal notranslate"><span class="pre">timeslot_counter</span></code> to count the number of timeslots it has on a single channel.
When this counter reaches <code class="docutils literal notranslate"><span class="pre">timeslots_per_channel</span></code>, the <code class="docutils literal notranslate"><span class="pre">timeslot_counter</span></code> is reset and the <code class="docutils literal notranslate"><span class="pre">channel_index</span></code> is incremented (cyclically).
When the Device has received an ACK, it knows the Host is using the current channel, but it does not know the <code class="docutils literal notranslate"><span class="pre">timeslot_counter</span></code> state on the Host.
As a result, only in the timeslots where the <code class="docutils literal notranslate"><span class="pre">timeslot_counter</span></code> equals zero the Device can be confident that it “guesses” the correct channel that the Host is monitoring.
Therefore, when an ACK is received, the <code class="docutils literal notranslate"><span class="pre">timeslot_counter</span></code> for the current timeslot is reset to zero, and a new Device transmission starts when the <code class="docutils literal notranslate"><span class="pre">timeslot_index</span></code> counter on the Device is zero.
Retransmission attempts, however, are sent on all timeslots.</p>
<p>Once the Device is in sync, it keeps an internal timer running to maintain the internal heartbeat in order to remain synchronized with the Host.
The duration the Device stays in the in sync state is the <code class="docutils literal notranslate"><span class="pre">sync_lifetime</span></code> and is measured in timeslots.
The <code class="docutils literal notranslate"><span class="pre">sync_lifetime</span></code> is reset whenever a packet is received.
Once the <code class="docutils literal notranslate"><span class="pre">sync_lifetime</span></code> has expired on a Device, the internal timer is stopped and the Device returns to out of sync state.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a Device that is in sync sends a packet but does not receive an ACK, it continues to transmit until it reaches the maximum number of attempts.</p>
</div>
<p>If you set the <code class="docutils literal notranslate"><span class="pre">sync_lifetime</span></code> to zero, the Device will never be in sync.
The <code class="docutils literal notranslate"><span class="pre">sync_lifetime</span></code> should be chosen with regard to how often packets are required to be sent and the fact that synchronization can only be maintained for a finite time due to clock drift and radio interference.
To configure the sync lifetime, use the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_sync_lifetime()</span></code> function.</p>
<p>The Device knows it is in sync when the number of retransmissions gets close to zero.
The <code class="xref c c-struct docutils literal notranslate"><span class="pre">nrf_gzll_device_tx_info_t</span></code> structure is passed to the Device callback functions, and it contains the number of transmit attempts required for the current packet.
In addition, the structure contains the <code class="docutils literal notranslate"><span class="pre">num_channel_switches</span></code> parameter that the application can use to determine whether the RF channels are reliable.
This enables the application to track bad channels and update the channel tables on Host and Device if desired.</p>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#id31">Backwards compatibility</a><a class="headerlink" href="#backwards-compatibility" title="Permalink to this heading"></a></h2>
<p>The Gazell Link Layer examples are not fully compatible out of the box with the legacy examples provided in the nRFgo SDK for the nRF24L IC.</p>
<p>The default timeslot period and channel tables require adjustment, as well as some setup to emulate the Gazell roles.
The Gazell Low Power Host role (Host role 1) is not supported in the nRF52 Series.</p>
<section id="channel-tables">
<h3><a class="toc-backref" href="#id32">Channel tables</a><a class="headerlink" href="#channel-tables" title="Permalink to this heading"></a></h3>
<p>The default channel tables require adjustment.</p>
<p>Depending on your project, do one of the following:</p>
<ul class="simple">
<li><p>Edit the <code class="file docutils literal notranslate"><span class="pre">gzll_params.h</span></code> file used in the nRF24L IC projects.</p></li>
<li><p>Use the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_channel_table()</span></code> function in the nRF52 Series projects.</p></li>
</ul>
</section>
<section id="timeslot-periods">
<h3><a class="toc-backref" href="#id33">Timeslot periods</a><a class="headerlink" href="#timeslot-periods" title="Permalink to this heading"></a></h3>
<p>The Gazell Link Layer supports the following minimum timeslot periods:</p>
<ul class="simple">
<li><p>600 us timeslot period, nRF52 Series Gazell Device to nRF52 Series Gazell Host.</p></li>
<li><p>504 us timeslot period, nRF52 Series Gazell Device to nRF24L IC Gazell Host.</p></li>
</ul>
<p>When using 504 us timeslot period, the following restrictions apply:</p>
<ul class="simple">
<li><p>The maximum payload size is 17 bytes.</p></li>
<li><p>The maximum ACK payload size is 10 bytes.</p></li>
</ul>
<p>In addition, the relation between the Device and Host timing parameters should be as follows:</p>
<ul class="simple">
<li><p>The Host listens to each channel in a GZLL_RX_PERIOD number of microseconds, where GZLL_RX_PERIOD is the heartbeat interval in the nRF24L IC.</p></li>
<li><p>The Host GZLL_RX_PERIOD must be greater than the time required to make two full transmission attempts on the Device (including ACK wait time).</p></li>
</ul>
<p>Depending on your project, do one of the following:</p>
<ul class="simple">
<li><p>Edit the <code class="file docutils literal notranslate"><span class="pre">gzll_params.h</span></code> file used in the nRF24L IC projects.</p></li>
<li><p>Use the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_set_timeslot_period()</span></code> function in the nRF52 Series projects (nRF52 Series Gazell timeslot period = 0.5*GZLL_RX_PERIOD).</p></li>
</ul>
</section>
<section id="emulating-legacy-gazell-roles">
<h3><a class="toc-backref" href="#id34">Emulating legacy Gazell roles</a><a class="headerlink" href="#emulating-legacy-gazell-roles" title="Permalink to this heading"></a></h3>
<p>The Gazell Link Layer protocol for the nRF52 Series is compatible with the most useful roles of the Gazell Link Layer for the nRF24L IC.</p>
<section id="emulating-legacy-gazell-device-role-2-and-host-role-0-on-the-nrf24-ic">
<h4>Emulating legacy Gazell Device role 2 and Host role 0 on the nRF24 IC<a class="headerlink" href="#emulating-legacy-gazell-device-role-2-and-host-role-0-on-the-nrf24-ic" title="Permalink to this heading"></a></h4>
<p>You can emulate the legacy Device role 2 as follows:</p>
<ul class="simple">
<li><p>The channel selection policy is equivalent to <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</span></code>.</p></li>
<li><p>When Gazell is out of sync, a large number of attempts may occur on each channel before the channel is switched.</p></li>
<li><p>When Gazell is in sync, a low number of transmission attempts, typically two, are allowed on each channel before the channel is switched.</p></li>
</ul>
<p>The legacy Host role 0 behaves as follows:</p>
<ul class="simple">
<li><p>Host is always on while it is enabled.</p></li>
<li><p>When enabled, the Host will continuously cycle through the channel table.</p></li>
</ul>
<p>See the example on how to achieve such behavior.
Assuming a channel table <code class="docutils literal notranslate"><span class="pre">my_channel_table[]</span></code> with three channels:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* On Host and Device */</span>
<span class="n">timeslots_per_channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">channel_table_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="n">nrf_gzll_set_timeslot_period</span><span class="p">(</span><span class="n">GZLL_RX_PERIOD</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="n">nrf_gzll_set_channel_table</span><span class="p">(</span><span class="n">my_channel_table</span><span class="p">,</span><span class="w"> </span><span class="n">channel_table_size</span><span class="p">);</span>
<span class="n">nrf_gzll_set_timeslots_per_channel</span><span class="p">(</span><span class="n">timeslots_per_channel</span><span class="p">);</span>
<span class="cm">/* On the Device */</span>
<span class="n">nrf_gzll_set_timeslots_per_channel_when_device_out_of_sync</span><span class="p">(</span><span class="n">channel_table_size</span><span class="o">*</span><span class="n">timeslots_per_channel</span><span class="p">);</span>
<span class="n">nrf_gzll_set_device_channel_selection_policy</span><span class="p">(</span><span class="n">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</span><span class="p">);</span>
</pre></div>
</div>
<figure class="align-default" id="id12">
<img alt="Emulating legacy Gazell" src="../../_images/gzll_fig9_gzll_config_example.svg" /><figcaption>
<p><span class="caption-text">Emulating legacy Gazell</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="transmission-statistics">
<h2><a class="toc-backref" href="#id35">Transmission statistics</a><a class="headerlink" href="#transmission-statistics" title="Permalink to this heading"></a></h2>
<p>The Gazell stack allows to automatically gather transmission information, such as:</p>
<ul class="simple">
<li><p>Total number of transmitted packets.</p></li>
<li><p>Total number of transmission timeouts.</p></li>
<li><p>Number of transmitted packets on each RF channel.</p></li>
<li><p>Number of transmission failures on each RF channel.</p></li>
</ul>
<p>The stack can also track packet transaction failure events, such as transmission timeout or receiving a packet with incorrect CRC.</p>
<p>To turn on transmission statistics, perform the following steps:</p>
<ol class="arabic simple">
<li><p>Define the <code class="xref c c-struct docutils literal notranslate"><span class="pre">nrf_gzll_tx_statistics_t</span></code> structure.
This is a buffer for transmission statistics data, so it must remain in memory as long as the transmission statistics are used.</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_init()</span></code> to initialize Gazell.</p></li>
<li><p>Call the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_tx_statistics_enable()</span></code> function to enable transmission information gathering.</p></li>
</ol>
<p>After this, transmission statistics can be read from the defined structure.
To reset the recording, call the <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_reset_tx_statistics()</span></code> function.</p>
<p>To track packet transaction failures, perform the following steps:</p>
<ol class="arabic simple">
<li><p>Define the <code class="docutils literal notranslate"><span class="pre">nrf_gzll_tx_timeout_callback</span></code> or <code class="docutils literal notranslate"><span class="pre">nrf_gzll_crc_failure_callback</span></code> functions that will be called on a proper event.</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_init()</span></code> to initialize Gazell.</p></li>
<li><p>Register the defined callbacks by calling <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_tx_timeout_callback_register()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">nrf_gzll_crc_failure_callback_register()</span></code>.</p></li>
</ol>
<p>After this, each transmission timeout and received packet CRC failure will be reported by the respective callback.</p>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gzp.html" class="btn btn-neutral float-right" title="Gazell Pairing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Gazell" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">

<table>
<tr>
<td>
    <p>
        &copy; Copyright 2019-2023, Nordic Semiconductor.
      Last updated on Mar 20, 2023.

    </p>
</td>
<td id="nordiclogo">
  <a href="https://www.nordicsemi.com/"><img src="../../_static/images/nordic-logo.png" border="0"/></a>
</td>
</tr>
</table>
  </div> 


</footer>

<div id="scroll-container">
  <button type="button" id="scroll-btn" class="btn">
    <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="#fff"/></svg>
  </button>
</div>

<script>
  const scrollBtn = document.querySelector("#scroll-btn");

  document.addEventListener("scroll", () => {
    if (window.scrollY > 400) {
          scrollBtn.style.visibility = "visible";
      } else {
          scrollBtn.style.visibility = "hidden";
      }
  });

  scrollBtn.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
  });
</script>
        </div>
      </div>
    </section>
  </div>
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> nRF Connect SDK</span>
       <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <div class="rst-other-version ncs">
        <a href="../../../nrf/index.html">nRF Connect SDK</a>
      </div>
      
      <div class="rst-other-version nrfx">
        <a href="../../../nrfx/index.html">nrfx</a>
      </div>
      
      <div class="rst-other-version nrfxlib">
        <a href="../../../nrfxlib/README.html">nrfxlib</a>
      </div>
      
      <div class="rst-other-version zephyr">
        <a href="../../../zephyr/index.html">Zephyr Project</a>
      </div>
      
      <div class="rst-other-version mcuboot">
        <a href="../../../mcuboot/wrapper.html">MCUboot</a>
      </div>
      
      <div class="rst-other-version tfm">
        <a href="../../../tfm/index.html">Trusted Firmware-M</a>
      </div>
      
      <div class="rst-other-version matter">
        <a href="../../../matter/index.html">Matter</a>
      </div>
      
      <div class="rst-other-version kconfig">
        <a href="../../../kconfig/index.html">Kconfig Reference</a>
      </div>
    </div>
  </div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>